{"ast":null,"code":"function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * @license\n * Copyright Paperbits. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file and at https://paperbits.io/license/mit.\n */\nimport * as _ from \"lodash\";\nimport * as FileSaver from \"file-saver\";\nimport * as Objects from \"@paperbits/common/objects\";\nimport { Operator, OrderDirection } from \"@paperbits/common/persistence\";\nconst pageSize = 20;\n/**\n * Static object storage for demo purposes. It stores all the uploaded blobs in memory.\n */\n\nexport let StaticObjectStorage = /*#__PURE__*/function () {\n  function StaticObjectStorage(httpClient) {\n    _classCallCheck(this, StaticObjectStorage);\n\n    _defineProperty(this, \"loadDataPromise\", void 0);\n\n    _defineProperty(this, \"storageDataObject\", void 0);\n\n    _defineProperty(this, \"splitter\", \"/\");\n  }\n\n  _createClass(StaticObjectStorage, [{\n    key: \"getData\",\n    value: async function getData() {\n      if (this.loadDataPromise) {\n        return this.loadDataPromise;\n      }\n\n      this.loadDataPromise = new Promise(async resolve => {\n        const response = await this.httpClient.send({\n          url: \"/data/demo.json\",\n          method: \"GET\"\n        });\n        this.storageDataObject = response.toObject();\n        resolve(this.storageDataObject);\n      });\n      return this.loadDataPromise;\n    }\n  }, {\n    key: \"addObject\",\n    value: async function addObject(path, dataObject) {\n      if (path) {\n        const pathParts = path.split(this.splitter);\n        const mainNode = pathParts[0];\n\n        if (pathParts.length === 1 || pathParts.length === 2 && !pathParts[1]) {\n          this.storageDataObject[mainNode] = dataObject;\n        } else {\n          if (!_.has(this.storageDataObject, mainNode)) {\n            this.storageDataObject[mainNode] = {};\n          }\n\n          this.storageDataObject[mainNode][pathParts[1]] = dataObject;\n        }\n      } else {\n        Object.keys(dataObject).forEach(prop => {\n          const obj = dataObject[prop];\n          const pathParts = prop.split(this.splitter);\n          const mainNode = pathParts[0];\n\n          if (pathParts.length === 1 || pathParts.length === 2 && !pathParts[1]) {\n            this.storageDataObject[mainNode] = obj;\n          } else {\n            if (!_.has(this.storageDataObject, mainNode)) {\n              this.storageDataObject[mainNode] = {};\n            }\n\n            this.storageDataObject[mainNode][pathParts[1]] = obj;\n          }\n        });\n      }\n    }\n  }, {\n    key: \"getObject\",\n    value: async function getObject(path) {\n      const data = await this.getData();\n      return Objects.getObjectAt(path, Objects.clone(data));\n    }\n  }, {\n    key: \"deleteObject\",\n    value: async function deleteObject(path) {\n      if (!path) {\n        return;\n      }\n\n      Objects.deleteNodeAt(path, this.storageDataObject);\n    }\n  }, {\n    key: \"updateObject\",\n    value: async function updateObject(path, dataObject) {\n      if (!path) {\n        return;\n      }\n\n      const clone = Objects.clone(dataObject);\n      Objects.setValue(path, this.storageDataObject, clone);\n      Objects.cleanupObject(clone); // Ensure all \"undefined\" are cleaned up\n    }\n  }, {\n    key: \"searchObjects\",\n    value: async function searchObjects(path, query) {\n      const data = await this.getData();\n\n      if (!data) {\n        return {\n          value: []\n        };\n      }\n\n      const searchObj = Objects.getObjectAt(path, data);\n\n      if (!searchObj) {\n        return {\n          value: []\n        };\n      }\n\n      let collection = Object.values(searchObj);\n\n      if (query) {\n        if (query.filters.length > 0) {\n          collection = collection.filter(x => {\n            let meetsCriteria = true;\n\n            for (const filter of query.filters) {\n              let left = Objects.getObjectAt(filter.left, x);\n              let right = filter.right;\n\n              if (left === undefined) {\n                meetsCriteria = false;\n                continue;\n              }\n\n              if (typeof left === \"string\") {\n                left = left.toUpperCase();\n              }\n\n              if (typeof right === \"string\") {\n                right = right.toUpperCase();\n              }\n\n              const operator = filter.operator;\n\n              switch (operator) {\n                case Operator.contains:\n                  if (left && !left.includes(right)) {\n                    meetsCriteria = false;\n                  }\n\n                  break;\n\n                case Operator.equals:\n                  if (left !== right) {\n                    meetsCriteria = false;\n                  }\n\n                  break;\n\n                default:\n                  throw new Error(\"Cannot translate operator into Firebase Realtime Database query.\");\n              }\n            }\n\n            return meetsCriteria;\n          });\n        }\n\n        if (query.orderingBy) {\n          const property = query.orderingBy;\n          collection = collection.sort((x, y) => {\n            const a = Objects.getObjectAt(property, x);\n            const b = Objects.getObjectAt(property, y);\n            const modifier = query.orderDirection === OrderDirection.accending ? 1 : -1;\n\n            if (a > b) {\n              return modifier;\n            }\n\n            if (a < b) {\n              return -modifier;\n            }\n\n            return 0;\n          });\n        }\n      }\n\n      const value = collection.slice(0, pageSize);\n      return new StaticPage(value, collection, pageSize);\n    }\n  }, {\n    key: \"saveChanges\",\n    value: async function saveChanges(delta) {\n      const saveTasks = [];\n      const keys = [];\n      Object.keys(delta).map(key => {\n        const firstLevelObject = delta[key];\n        Object.keys(firstLevelObject).forEach(subkey => {\n          keys.push(`${key}/${subkey}`);\n        });\n      });\n      keys.forEach(key => {\n        const changeObject = Objects.getObjectAt(key, delta);\n\n        if (changeObject) {\n          saveTasks.push(this.updateObject(key, changeObject));\n        } else {\n          saveTasks.push(this.deleteObject(key));\n        }\n      });\n      await Promise.all(saveTasks);\n      const state = JSON.stringify(this.storageDataObject);\n      const stateBlob = new Blob([state], {\n        type: \"text/plain;charset=utf-8\"\n      });\n      FileSaver.saveAs(stateBlob, \"demo.json\");\n      /* Uncomment to save changes in a separate file */\n      // const changes = JSON.stringify(delta);\n      // const deltaBlob = new Blob([changes], { type: \"text/plain;charset=utf-8\" });\n      // FileSaver.saveAs(deltaBlob, \"changes.json\");\n    }\n  }, {\n    key: \"loadData\",\n    value: async function loadData() {\n      return new Promise((resolve, reject) => {\n        const input = document.createElement(\"input\");\n        input.type = \"file\";\n\n        input.onchange = e => {\n          const target = e.target;\n          const file = target.files[0];\n\n          if (!file) {\n            resolve(undefined);\n          }\n\n          const reader = new FileReader();\n          reader.readAsText(file, \"UTF-8\");\n\n          reader.onload = readerEvent => {\n            const contentString = readerEvent.target.result.toString();\n            const dataObject = contentString ? JSON.parse(contentString) : undefined;\n            this.storageDataObject = dataObject || this.storageDataObject;\n            this.loadDataPromise = new Promise(resolve => resolve(this.storageDataObject));\n            resolve(dataObject);\n          };\n        };\n\n        input.click();\n      });\n    }\n  }]);\n\n  return StaticObjectStorage;\n}();\n\nlet StaticPage = /*#__PURE__*/function () {\n  function StaticPage(value, collection, skip) {\n    _classCallCheck(this, StaticPage);\n\n    if (skip > this.collection.length) {\n      this.takeNext = null;\n    }\n  }\n\n  _createClass(StaticPage, [{\n    key: \"takePrev\",\n    value: async function takePrev() {\n      throw new Error(\"Not implemented\");\n    }\n  }, {\n    key: \"takeNext\",\n    value: async function takeNext() {\n      const value = this.collection.slice(this.skip, this.skip + pageSize);\n      const skipNext = this.skip + pageSize;\n      const nextPage = new StaticPage(value, this.collection, skipNext);\n      return nextPage;\n    }\n  }]);\n\n  return StaticPage;\n}();","map":{"version":3,"sources":["/usr/local/src/app/packages/craflo-frontend/paperbits/src/persistence/staticObjectStorage.ts"],"names":["_","FileSaver","Objects","Operator","OrderDirection","pageSize","StaticObjectStorage","httpClient","loadDataPromise","Promise","resolve","response","send","url","method","storageDataObject","toObject","path","dataObject","pathParts","split","splitter","mainNode","length","has","Object","keys","forEach","prop","obj","data","getData","getObjectAt","clone","deleteNodeAt","setValue","cleanupObject","query","value","searchObj","collection","values","filters","filter","x","meetsCriteria","left","right","undefined","toUpperCase","operator","contains","includes","equals","Error","orderingBy","property","sort","y","a","b","modifier","orderDirection","accending","slice","StaticPage","delta","saveTasks","map","key","firstLevelObject","subkey","push","changeObject","updateObject","deleteObject","all","state","JSON","stringify","stateBlob","Blob","type","saveAs","reject","input","document","createElement","onchange","e","target","file","files","reader","FileReader","readAsText","onload","readerEvent","contentString","result","toString","parse","click","skip","takeNext","skipNext","nextPage"],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Paperbits. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file and at https://paperbits.io/license/mit.\n */\n\n\nimport * as _ from \"lodash\";\nimport * as FileSaver from \"file-saver\";\nimport * as Objects from \"@paperbits/common/objects\";\nimport { HttpClient } from \"@paperbits/common/http\";\nimport { IObjectStorage, Query, Operator, OrderDirection, Page } from \"@paperbits/common/persistence\";\n\nconst pageSize = 20;\n\n/**\n * Static object storage for demo purposes. It stores all the uploaded blobs in memory.\n */\nexport class StaticObjectStorage implements IObjectStorage {\n    private loadDataPromise: Promise<Object>;\n    protected storageDataObject: Object;\n    private splitter = \"/\";\n\n    constructor(private readonly httpClient: HttpClient) { }\n\n    protected async getData(): Promise<Object> {\n        if (this.loadDataPromise) {\n            return this.loadDataPromise;\n        }\n\n        this.loadDataPromise = new Promise<Object>(async (resolve) => {\n            const response = await this.httpClient.send({\n                url: \"/data/demo.json\",\n                method: \"GET\"\n            });\n\n            this.storageDataObject = response.toObject();\n\n            resolve(this.storageDataObject);\n        });\n\n        return this.loadDataPromise;\n    }\n\n    public async addObject(path: string, dataObject: Object): Promise<void> {\n        if (path) {\n            const pathParts = path.split(this.splitter);\n            const mainNode = pathParts[0];\n\n            if (pathParts.length === 1 || (pathParts.length === 2 && !pathParts[1])) {\n                this.storageDataObject[mainNode] = dataObject;\n            }\n            else {\n                if (!_.has(this.storageDataObject, mainNode)) {\n                    this.storageDataObject[mainNode] = {};\n                }\n                this.storageDataObject[mainNode][pathParts[1]] = dataObject;\n            }\n        }\n        else {\n            Object.keys(dataObject).forEach(prop => {\n                const obj = dataObject[prop];\n                const pathParts = prop.split(this.splitter);\n                const mainNode = pathParts[0];\n\n                if (pathParts.length === 1 || (pathParts.length === 2 && !pathParts[1])) {\n                    this.storageDataObject[mainNode] = obj;\n                }\n                else {\n                    if (!_.has(this.storageDataObject, mainNode)) {\n                        this.storageDataObject[mainNode] = {};\n                    }\n                    this.storageDataObject[mainNode][pathParts[1]] = obj;\n                }\n            });\n        }\n    }\n\n    public async getObject<T>(path: string): Promise<T> {\n        const data = await this.getData();\n\n        return Objects.getObjectAt(path, Objects.clone(data));\n    }\n\n    public async deleteObject(path: string): Promise<void> {\n        if (!path) {\n            return;\n        }\n\n        Objects.deleteNodeAt(path, this.storageDataObject);\n    }\n\n    public async updateObject<T>(path: string, dataObject: T): Promise<void> {\n        if (!path) {\n            return;\n        }\n\n        const clone: any = Objects.clone(dataObject);\n        Objects.setValue(path, this.storageDataObject, clone);\n        Objects.cleanupObject(clone); // Ensure all \"undefined\" are cleaned up\n    }\n\n    public async searchObjects<T>(path: string, query: Query<T>): Promise<Page<T>> {\n        const data = await this.getData();\n\n        if (!data) {\n            return { value: [] };\n        }\n\n        const searchObj = Objects.getObjectAt(path, data);\n\n        if (!searchObj) {\n            return { value: [] };\n        }\n\n        let collection: any[] = Object.values(searchObj);\n\n        if (query) {\n            if (query.filters.length > 0) {\n                collection = collection.filter(x => {\n                    let meetsCriteria = true;\n\n                    for (const filter of query.filters) {\n                        let left = Objects.getObjectAt<any>(filter.left, x);\n                        let right = filter.right;\n\n                        if (left === undefined) {\n                            meetsCriteria = false;\n                            continue;\n                        }\n\n                        if (typeof left === \"string\") {\n                            left = left.toUpperCase();\n                        }\n\n                        if (typeof right === \"string\") {\n                            right = right.toUpperCase();\n                        }\n\n                        const operator = filter.operator;\n\n                        switch (operator) {\n                            case Operator.contains:\n                                if (left && !left.includes(right)) {\n                                    meetsCriteria = false;\n                                }\n                                break;\n\n                            case Operator.equals:\n                                if (left !== right) {\n                                    meetsCriteria = false;\n                                }\n                                break;\n\n                            default:\n                                throw new Error(\"Cannot translate operator into Firebase Realtime Database query.\");\n                        }\n                    }\n\n                    return meetsCriteria;\n                });\n            }\n\n            if (query.orderingBy) {\n                const property = query.orderingBy;\n\n                collection = collection.sort((x, y) => {\n                    const a = Objects.getObjectAt<any>(property, x);\n                    const b = Objects.getObjectAt<any>(property, y);\n                    const modifier = query.orderDirection === OrderDirection.accending ? 1 : -1;\n\n                    if (a > b) {\n                        return modifier;\n                    }\n\n                    if (a < b) {\n                        return -modifier;\n                    }\n\n                    return 0;\n                });\n            }\n        }\n\n        const value = collection.slice(0, pageSize);\n\n        return new StaticPage(value, collection, pageSize);\n    }\n\n    public async saveChanges(delta: Object): Promise<void> {\n        const saveTasks = [];\n        const keys = [];\n\n        Object.keys(delta).map(key => {\n            const firstLevelObject = delta[key];\n\n            Object.keys(firstLevelObject).forEach(subkey => {\n                keys.push(`${key}/${subkey}`);\n            });\n        });\n\n        keys.forEach(key => {\n            const changeObject = Objects.getObjectAt(key, delta);\n\n            if (changeObject) {\n                saveTasks.push(this.updateObject(key, changeObject));\n            }\n            else {\n                saveTasks.push(this.deleteObject(key));\n            }\n        });\n\n        await Promise.all(saveTasks);\n\n        const state = JSON.stringify(this.storageDataObject);\n        const stateBlob = new Blob([state], { type: \"text/plain;charset=utf-8\" });\n\n        FileSaver.saveAs(stateBlob, \"demo.json\");\n\n        /* Uncomment to save changes in a separate file */\n        // const changes = JSON.stringify(delta);\n        // const deltaBlob = new Blob([changes], { type: \"text/plain;charset=utf-8\" });\n        // FileSaver.saveAs(deltaBlob, \"changes.json\");\n    }\n\n    public async loadData(): Promise<object> {\n        return new Promise<object>((resolve, reject) => {\n            const input: HTMLInputElement = document.createElement(\"input\");\n            input.type = \"file\";\n\n            input.onchange = e => {\n\n                const target: HTMLInputElement = <HTMLInputElement>e.target;\n                const file = target.files[0];\n\n                if (!file) {\n                    resolve(undefined);\n                }\n\n                const reader = new FileReader();\n                reader.readAsText(file, \"UTF-8\");\n\n                reader.onload = readerEvent => {\n                    const contentString = readerEvent.target.result.toString();\n                    const dataObject = contentString ? JSON.parse(contentString) : undefined;\n                    this.storageDataObject = dataObject || this.storageDataObject;\n\n                    this.loadDataPromise = new Promise<Object>(resolve => resolve(this.storageDataObject));\n\n                    resolve(dataObject);\n                };\n\n            };\n\n            input.click();\n        });\n    }\n}\n\nclass StaticPage<T> implements Page<T> {\n    constructor(\n        public readonly value: T[],\n        private readonly collection: any,\n        private readonly skip: number,\n    ) {\n        if (skip > this.collection.length) {\n            this.takeNext = null;\n        }\n    }\n\n    public async takePrev?(): Promise<Page<T>> {\n        throw new Error(\"Not implemented\");\n    }\n\n    public async takeNext?(): Promise<Page<T>> {\n        const value = this.collection.slice(this.skip, this.skip + pageSize);\n        const skipNext = this.skip + pageSize;\n        const nextPage = new StaticPage<T>(value, this.collection, skipNext);\n\n        return nextPage;\n    }\n}"]},"metadata":{},"sourceType":"module"}