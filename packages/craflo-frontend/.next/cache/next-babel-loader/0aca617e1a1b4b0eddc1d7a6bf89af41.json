{"ast":null,"code":"function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * @license\n * Copyright Paperbits. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file and at https://paperbits.io/license/mit.\n */\nimport * as Utils from \"@paperbits/common/utils\";\n\n/**\n * Static blob storage for demo purposes. It stores all the uploaded blobs in memory.\n */\nexport let StaticBlobStorage = /*#__PURE__*/function () {\n  function StaticBlobStorage() {\n    _classCallCheck(this, StaticBlobStorage);\n\n    _defineProperty(this, \"storageDataObject\", {});\n  }\n\n  _createClass(StaticBlobStorage, [{\n    key: \"uploadBlob\",\n\n    /**\n     * Uploads specified content into browser memory and stores it as base64 string.\n     * @param blobKey \n     * @param content \n     * @param contentType \n     */\n    value: async function uploadBlob(blobKey, content, contentType) {\n      this.storageDataObject[blobKey] = {\n        contentType: contentType,\n        content: content\n      };\n    }\n    /**\n     * Returns download URL of uploaded blob.\n     * @param blobKey \n     */\n\n  }, {\n    key: \"getDownloadUrl\",\n    value: async function getDownloadUrl(blobKey) {\n      const blobRecord = this.storageDataObject[blobKey];\n\n      if (!blobRecord) {\n        return null;\n      }\n\n      return `data:${blobRecord.contentType};base64,${Utils.arrayBufferToBase64(blobRecord.content)}`;\n    }\n    /**\n     * Removes specified blob from memory.\n     * @param blobKey \n     */\n\n  }, {\n    key: \"deleteBlob\",\n    value: async function deleteBlob(blobKey) {\n      delete this.storageDataObject[blobKey];\n    }\n  }, {\n    key: \"downloadBlob\",\n    value: async function downloadBlob(blobKey) {\n      const blobRecord = this.storageDataObject[blobKey];\n\n      if (blobRecord) {\n        return blobRecord.content;\n      } else {\n        return null;\n      }\n    }\n  }]);\n\n  return StaticBlobStorage;\n}();","map":{"version":3,"sources":["/usr/local/src/app/packages/craflo-frontend/src/paperbits/persistence/staticBlobStorage.ts"],"names":["Utils","StaticBlobStorage","blobKey","content","contentType","storageDataObject","blobRecord","arrayBufferToBase64"],"mappings":";;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA,OAAO,KAAKA,KAAZ,MAAuB,yBAAvB;;AAIA;AACA;AACA;AACA,WAAaC,iBAAb;AAAA;AAAA;;AAAA,+CACgC,EADhC;AAAA;;AAAA;AAAA;;AAGI;AACJ;AACA;AACA;AACA;AACA;AARA,qCAS4BC,OAT5B,EAS6CC,OAT7C,EASkEC,WATlE,EASuG;AAC/F,WAAKC,iBAAL,CAAuBH,OAAvB,IAAkC;AAC9BE,QAAAA,WAAW,EAAEA,WADiB;AAE9BD,QAAAA,OAAO,EAAEA;AAFqB,OAAlC;AAIH;AAED;AACJ;AACA;AACA;;AAnBA;AAAA;AAAA,yCAoBgCD,OApBhC,EAoBkE;AAC1D,YAAMI,UAAU,GAAG,KAAKD,iBAAL,CAAuBH,OAAvB,CAAnB;;AAEA,UAAI,CAACI,UAAL,EAAiB;AACb,eAAO,IAAP;AACH;;AAED,aAAQ,QAAOA,UAAU,CAACF,WAAY,WAAUJ,KAAK,CAACO,mBAAN,CAA0BD,UAAU,CAACH,OAArC,CAA8C,EAA9F;AACH;AAED;AACJ;AACA;AACA;;AAjCA;AAAA;AAAA,qCAkC4BD,OAlC5B,EAkC4D;AACpD,aAAO,KAAKG,iBAAL,CAAuBH,OAAvB,CAAP;AACH;AApCL;AAAA;AAAA,uCAsC+BA,OAtC/B,EAsCqE;AAC7D,YAAMI,UAAU,GAAG,KAAKD,iBAAL,CAAuBH,OAAvB,CAAnB;;AAEA,UAAII,UAAJ,EAAgB;AACZ,eAAOA,UAAU,CAACH,OAAlB;AACH,OAFD,MAGK;AACD,eAAO,IAAP;AACH;AACJ;AA/CL;;AAAA;AAAA","sourcesContent":["/**\n * @license\n * Copyright Paperbits. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file and at https://paperbits.io/license/mit.\n */\n\n\nimport * as Utils from \"@paperbits/common/utils\";\nimport { IBlobStorage } from \"@paperbits/common/persistence\";\n\n\n/**\n * Static blob storage for demo purposes. It stores all the uploaded blobs in memory.\n */\nexport class StaticBlobStorage implements IBlobStorage {\n    private storageDataObject = {};\n\n    /**\n     * Uploads specified content into browser memory and stores it as base64 string.\n     * @param blobKey \n     * @param content \n     * @param contentType \n     */\n    public async uploadBlob(blobKey: string, content: Uint8Array, contentType?: string): Promise<void> {\n        this.storageDataObject[blobKey] = {\n            contentType: contentType,\n            content: content\n        };\n    }\n\n    /**\n     * Returns download URL of uploaded blob.\n     * @param blobKey \n     */\n    public async getDownloadUrl(blobKey: string): Promise<string> {\n        const blobRecord = this.storageDataObject[blobKey];\n\n        if (!blobRecord) {\n            return null;\n        }\n\n        return `data:${blobRecord.contentType};base64,${Utils.arrayBufferToBase64(blobRecord.content)}`;\n    }\n\n    /**\n     * Removes specified blob from memory.\n     * @param blobKey \n     */\n    public async deleteBlob(blobKey: string): Promise<void> {\n        delete this.storageDataObject[blobKey];\n    }\n\n    public async downloadBlob?(blobKey: string): Promise<Uint8Array> {\n        const blobRecord = this.storageDataObject[blobKey];\n\n        if (blobRecord) {\n            return blobRecord.content;\n        }\n        else {\n            return null;\n        }\n    }\n}\n\n"]},"metadata":{},"sourceType":"module"}