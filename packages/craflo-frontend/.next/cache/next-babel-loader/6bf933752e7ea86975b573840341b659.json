{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n/**\n * Load next page of content for a Apollo GraphQL query\n * @name loadNextPage\n * @param {Object} args Args for pagination\n * @param {String} args.queryName Name of the GraphQL whose result will be used to paginate\n * @param {Object} args.data Full result from GraphQl\n * @param {Object} args.limit Limit\n * @param {Object} args.fetchMore fetchMore function\n * @returns {Function} load next page function\n */\nexport var loadNextPage = function loadNextPage(_ref) {\n  var queryName = _ref.queryName,\n      data = _ref.data,\n      limit = _ref.limit,\n      fetchMore = _ref.fetchMore,\n      routingStore = _ref.routingStore;\n  return function () {\n    if (!queryName) throw new Error(\"queryName is required\");\n    var cursor = data[queryName].pageInfo.endCursor; // Set URL search params to allow for link sharing\n\n    if (routingStore) {\n      routingStore.setSearch({\n        limit: limit,\n        after: cursor\n      });\n    }\n\n    fetchMore({\n      variables: {\n        first: limit,\n        after: cursor,\n        last: null,\n        before: null\n      },\n      updateQuery: function updateQuery(previousResult, _ref2) {\n        var fetchMoreResult = _ref2.fetchMoreResult;\n        var items = fetchMoreResult[queryName]; // Return with additional results\n\n        if (items.edges.length) {\n          return fetchMoreResult;\n        } // Send the previous result if the new result contains no additional data\n\n\n        return previousResult;\n      }\n    });\n  };\n};\n/**\n * Load previous page of content for a Apollo GraphQL query\n * @name loadPreviousPage\n * @param {Object} args Args for pagination\n * @param {String} args.queryName Name of the GraphQL whose result will be used to paginate\n * @param {Object} args.data Full result from GraphQl\n * @param {Object} args.limit Limit\n * @param {Object} args.fetchMore fetchMore function\n * @returns {Function} load next page function\n */\n\nexport var loadPreviousPage = function loadPreviousPage(_ref3) {\n  var queryName = _ref3.queryName,\n      data = _ref3.data,\n      limit = _ref3.limit,\n      fetchMore = _ref3.fetchMore,\n      routingStore = _ref3.routingStore;\n  return function () {\n    if (!queryName) throw new Error(\"queryName is required\");\n    var cursor = data[queryName].pageInfo.startCursor; // Set URL search params to allow for link sharing\n\n    if (routingStore) {\n      routingStore.setSearch({\n        limit: limit,\n        before: cursor\n      });\n    }\n\n    fetchMore({\n      variables: {\n        first: null,\n        after: null,\n        last: limit,\n        before: cursor\n      },\n      updateQuery: function updateQuery(previousResult, _ref4) {\n        var fetchMoreResult = _ref4.fetchMoreResult;\n        var items = fetchMoreResult[queryName]; // Return with additional results\n\n        if (items.edges.length) {\n          return fetchMoreResult;\n        } // Send the previous result if the new result contains no additional data\n\n\n        return previousResult;\n      }\n    });\n  };\n};\n/**\n * Create pagination functions for next and previous and page info data\n * @name pagination\n * @param {Object} args Args for pagination\n * @param {String} args.queryName Name of the GraphQL whose result will be used to paginate\n * @param {Object} args.data Full result from GraphQl\n * @param {Object} args.limit Limit\n * @param {Object} args.fetchMore fetchMore function\n * @returns {Function} load next page function\n */\n\nexport var pagination = function pagination(args) {\n  var queryName = args.queryName,\n      data = args.data;\n  if (!queryName) throw new Error(\"queryName is required\");\n  var pageInfo = data && data[queryName] && data[queryName].pageInfo || {};\n  return _objectSpread(_objectSpread({}, pageInfo), {}, {\n    loadNextPage: loadNextPage(args),\n    loadPreviousPage: loadPreviousPage(args)\n  });\n};\n/**\n * Create an object of variables for pagination a GraphQL query.\n * @name paginationVariablesFromUrlParams\n * @param {Object} params Object of params to create query variables from\n * @param {Number|String} params.limit Maximum number of items to get\n * @param {String} params.before Before Cursor\n * @param {String} params.after After cursor\n * @param {Options} options Additional options\n * @param {Number} options.defaultLimit After cursor\n * @returns {Object} Object of variables for GraphQL query\n */\n\nexport var paginationVariablesFromUrlParams = function paginationVariablesFromUrlParams(params, options) {\n  var _ref5 = params || {},\n      limit = _ref5.limit,\n      before = _ref5.before,\n      after = _ref5.after;\n\n  var _ref6 = options || {},\n      defaultPageLimit = _ref6.defaultPageLimit;\n\n  var variables = {};\n\n  if (limit && after) {\n    variables.first = parseInt(limit, 10);\n  } else if (limit && before) {\n    variables.last = parseInt(limit, 10);\n  } else if (limit) {\n    variables.first = parseInt(limit, 10);\n  } else if (defaultPageLimit) {\n    variables.first = defaultPageLimit;\n  }\n\n  if (after) {\n    variables.after = after;\n  } else if (before) {\n    variables.before = before;\n  }\n\n  return variables;\n};","map":{"version":3,"sources":["/usr/local/src/app/packages/craflo-frontend/src/reaction/lib/utils/pagination.tsx"],"names":["loadNextPage","queryName","data","limit","fetchMore","routingStore","Error","cursor","pageInfo","endCursor","setSearch","after","variables","first","last","before","updateQuery","previousResult","fetchMoreResult","items","edges","length","loadPreviousPage","startCursor","pagination","args","paginationVariablesFromUrlParams","params","options","defaultPageLimit","parseInt"],"mappings":"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","sourcesContent":["/**\n * Load next page of content for a Apollo GraphQL query\n * @name loadNextPage\n * @param {Object} args Args for pagination\n * @param {String} args.queryName Name of the GraphQL whose result will be used to paginate\n * @param {Object} args.data Full result from GraphQl\n * @param {Object} args.limit Limit\n * @param {Object} args.fetchMore fetchMore function\n * @returns {Function} load next page function\n */\nexport const loadNextPage = ({ queryName, data, limit, fetchMore, routingStore }) => () => {\n  if (!queryName) throw new Error(\"queryName is required\");\n\n  const cursor = data[queryName].pageInfo.endCursor;\n\n  // Set URL search params to allow for link sharing\n  if (routingStore) {\n    routingStore.setSearch({ limit, after: cursor });\n  }\n\n  fetchMore({\n    variables: {\n      first: limit,\n      after: cursor,\n      last: null,\n      before: null\n    },\n    updateQuery: (previousResult, { fetchMoreResult }) => {\n      const { [queryName]: items } = fetchMoreResult;\n\n      // Return with additional results\n      if (items.edges.length) {\n        return fetchMoreResult;\n      }\n\n      // Send the previous result if the new result contains no additional data\n      return previousResult;\n    }\n  });\n};\n\n/**\n * Load previous page of content for a Apollo GraphQL query\n * @name loadPreviousPage\n * @param {Object} args Args for pagination\n * @param {String} args.queryName Name of the GraphQL whose result will be used to paginate\n * @param {Object} args.data Full result from GraphQl\n * @param {Object} args.limit Limit\n * @param {Object} args.fetchMore fetchMore function\n * @returns {Function} load next page function\n */\nexport const loadPreviousPage = ({ queryName, data, limit, fetchMore, routingStore }) => () => {\n  if (!queryName) throw new Error(\"queryName is required\");\n\n  const cursor = data[queryName].pageInfo.startCursor;\n\n  // Set URL search params to allow for link sharing\n  if (routingStore) {\n    routingStore.setSearch({ limit, before: cursor });\n  }\n\n  fetchMore({\n    variables: {\n      first: null,\n      after: null,\n      last: limit,\n      before: cursor\n    },\n    updateQuery: (previousResult, { fetchMoreResult }) => {\n      const { [queryName]: items } = fetchMoreResult;\n\n      // Return with additional results\n      if (items.edges.length) {\n        return fetchMoreResult;\n      }\n\n      // Send the previous result if the new result contains no additional data\n      return previousResult;\n    }\n  });\n};\n\n/**\n * Create pagination functions for next and previous and page info data\n * @name pagination\n * @param {Object} args Args for pagination\n * @param {String} args.queryName Name of the GraphQL whose result will be used to paginate\n * @param {Object} args.data Full result from GraphQl\n * @param {Object} args.limit Limit\n * @param {Object} args.fetchMore fetchMore function\n * @returns {Function} load next page function\n */\nexport const pagination = (args) => {\n  const { queryName, data } = args;\n\n  if (!queryName) throw new Error(\"queryName is required\");\n\n  const pageInfo = (data && data[queryName] && data[queryName].pageInfo) || {};\n\n  return {\n    ...pageInfo,\n    loadNextPage: loadNextPage(args),\n    loadPreviousPage: loadPreviousPage(args)\n  };\n};\n\n/**\n * Create an object of variables for pagination a GraphQL query.\n * @name paginationVariablesFromUrlParams\n * @param {Object} params Object of params to create query variables from\n * @param {Number|String} params.limit Maximum number of items to get\n * @param {String} params.before Before Cursor\n * @param {String} params.after After cursor\n * @param {Options} options Additional options\n * @param {Number} options.defaultLimit After cursor\n * @returns {Object} Object of variables for GraphQL query\n */\nexport const paginationVariablesFromUrlParams = (params, options) => {\n  const { limit, before, after } = params || {};\n  const { defaultPageLimit } = options || {};\n  const variables = {};\n\n  if (limit && after) {\n    variables.first = parseInt(limit, 10);\n  } else if (limit && before) {\n    variables.last = parseInt(limit, 10);\n  } else if (limit) {\n    variables.first = parseInt(limit, 10);\n  } else if (defaultPageLimit) {\n    variables.first = defaultPageLimit;\n  }\n\n  if (after) {\n    variables.after = after;\n  } else if (before) {\n    variables.before = before;\n  }\n\n  return variables;\n};\n"]},"metadata":{},"sourceType":"module"}