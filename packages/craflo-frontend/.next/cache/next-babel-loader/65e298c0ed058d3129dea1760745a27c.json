{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nvar _jsxFileName = \"/usr/local/src/app/packages/craflo-frontend/src/reaction/components/ProgressiveImage/ProgressiveImage.tsx\";\nvar __jsx = React.createElement;\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nimport React, { Component } from \"react\";\nimport PropTypes from \"prop-types\";\nimport { ContainerQuery } from \"react-container-query\";\nimport styled from \"styled-components\";\nimport { applyTheme } from \"@reactioncommerce/components/utils\";\nimport NextImage from 'next/image';\nvar imageContainerQueries = {\n  isLargeWidth: {\n    minWidth: 301 // Use medium image (600px) until container width is greater than image width / 2 (up to 2x scaling)\n\n  }\n};\n/**\n * @file Image component does a \"Medium/Instagram\" like progressive loading effect for images.\n * To achieve this the component first renders an img element with a tiny version of the full resolution image.\n * This low res image should download quickly and will be blurred by the CSS removing the pixelation.\n * The component then creates an Image buffer with a src of the full resolution image.\n * Once the buffer loads the full resolution image the blurred low res img will fade out revealing the full res image.\n *\n */\n\nvar ImageWrapper = styled.div.withConfig({\n  displayName: \"ProgressiveImage__ImageWrapper\",\n  componentId: \"sc-1xkhq8s-0\"\n})([\"background-color:\", \";display:block;height:\", \"px;overflow:hidden;padding-top:100%;position:relative;border-radius:0.75rem 0.75rem  0.75rem 0.75rem;width:100%;padding:0px;transition:all 0.3s cubic-bezier(0.4,0,0.2,1);transition-delay:0.05s;&:hover{transform:scale(1.05);}\"], applyTheme(\"ProgressiveImage.backgroundColor\"), function (props) {\n  return props.imgH;\n});\n_c = ImageWrapper;\nvar Img = styled(NextImage).withConfig({\n  displayName: \"ProgressiveImage__Img\",\n  componentId: \"sc-1xkhq8s-1\"\n})([\"width:\", \";height:\", \";left:50% !important;opacity:1;position:absolute;transition:opacity 300ms cubic-bezier(0.4,0,0.2,1);top:50% !important;transform:translate(-50%,-50%);\", \"\"], function (_ref) {\n  var fit = _ref.fit;\n  return fit === \"contain\" && \"100%\" || \"auto\";\n}, function (_ref2) {\n  var fit = _ref2.fit,\n      fixWidth = _ref2.fixWidth;\n  return fit === \"cover\" && \"100%\" || \"auto\";\n}, function (_ref3) {\n  var isLoading = _ref3.isLoading,\n      isLoaded = _ref3.isLoaded,\n      isHidden = _ref3.isHidden;\n  var styles = \"\";\n\n  if (isLoading) {\n    styles += \"\\n        filter: blur(8px);\\n        z-index: 9;\";\n  }\n\n  if (isLoaded) {\n    styles += \"z-index: 0;\";\n  }\n\n  if (isHidden) {\n    styles += \"opacity: 0;\";\n  }\n\n  return styles;\n});\n_c2 = Img;\n\nvar ProgressiveImage = /*#__PURE__*/function (_Component) {\n  _inherits(ProgressiveImage, _Component);\n\n  var _super = _createSuper(ProgressiveImage);\n\n  function ProgressiveImage() {\n    var _this;\n\n    _classCallCheck(this, ProgressiveImage);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n\n    _defineProperty(_assertThisInitialized(_this), \"state\", {\n      ready: false\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"_mounted\", false);\n\n    _defineProperty(_assertThisInitialized(_this), \"_wrapper\", null);\n\n    return _this;\n  }\n\n  _createClass(ProgressiveImage, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this._mounted = true;\n\n      if (true) {\n        this.lazyLoad();\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this._mounted = false;\n    }\n    /**\n     * Private check for component mount, used in image buffer\n     */\n\n  }, {\n    key: \"lazyLoad\",\n\n    /**\n     *\n     * @method lazyLoad\n     * @summary If `IntersectionObserver` is supported create a new one and watch for the `_wrapper` element\n     * to scroll within the viewport, once it's with 50px of the viewport start loading the full res image.\n     * If the `IntersectionObserver` isn't supported just load the image normally.\n     * https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API\n     * @return {Undefined} Nothing\n     */\n    value: function lazyLoad() {\n      var _this2 = this;\n\n      if (this.supportIntersectionObserver) {\n        var viewportIntersection = new IntersectionObserver(function (entries) {\n          entries.forEach(function (entry) {\n            if (entry.intersectionRatio > 0 && !_this2.state.ready) {\n              _this2.loadImage();\n            }\n          });\n        }, {\n          root: null,\n          rootMargin: \"50px 0px\",\n          threshold: 0.01\n        });\n        viewportIntersection.observe(this._wrapper);\n      } else {\n        this.loadImage();\n      }\n    }\n    /**\n     *\n     * @method loadImage\n     * @summary Create a new `Image` buffer and set the `src` to be\n     * ether the `props.src` or `props.srcs.medium` if a responsive picture.\n     * Once the buffer loads set the `ready` state to `true`\n     * @return {Undefined} Nothing\n     */\n\n  }, {\n    key: \"loadImage\",\n    value: function loadImage() {\n      var _this3 = this;\n\n      var _this$props = this.props,\n          src = _this$props.src,\n          srcs = _this$props.srcs;\n      var buffer = new Image();\n\n      buffer.onload = function () {\n        _this3._mounted && _this3.setState({\n          ready: true\n        });\n      };\n\n      buffer.src = src || srcs && srcs.medium;\n    }\n    /**\n     *\n     * @method renderResponsiveImage\n     * @summary Renders an image that uses medium by default, and large when appropriate container width\n     *  (see imageContainerQueries definition)\n     * @return {Element} - `picture`\n     */\n\n  }, {\n    key: \"renderResponsiveImage\",\n    value: function renderResponsiveImage() {\n      var _this4 = this;\n\n      var _this$props2 = this.props,\n          altText = _this$props2.altText,\n          fit = _this$props2.fit,\n          srcs = _this$props2.srcs;\n      var medium = srcs.medium,\n          large = srcs.large;\n      var _this$props3 = this.props,\n          imgW = _this$props3.imgW,\n          imgH = _this$props3.imgH;\n      return /*#__PURE__*/React.createElement(ContainerQuery, {\n        query: imageContainerQueries,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 206,\n          columnNumber: 7\n        }\n      }, function (params) {\n        var src = medium;\n        var isLargeWidth = params.isLargeWidth;\n\n        if (isLargeWidth) {\n          src = large;\n        }\n\n        return /*#__PURE__*/React.createElement(Img, {\n          src: src,\n          isLoaded: true,\n          alt: altText,\n          fit: fit,\n          width: imgW,\n          height: imgH,\n          __self: _this4,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 215,\n            columnNumber: 13\n          }\n        });\n      });\n    }\n    /**\n     *\n     * @method renderImg\n     * @summary Renders a `img` element with the provided `props.src`\n     * @return {Element} - `img`\n     */\n\n  }, {\n    key: \"renderImg\",\n    value: function renderImg() {\n      var _this$props4 = this.props,\n          altText = _this$props4.altText,\n          fit = _this$props4.fit,\n          src = _this$props4.src;\n      var _this$props5 = this.props,\n          imgW = _this$props5.imgW,\n          imgH = _this$props5.imgH;\n      return /*#__PURE__*/React.createElement(Img, {\n        src: src,\n        isLoaded: true,\n        alt: altText,\n        fit: fit,\n        width: imgW,\n        height: imgH,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 238,\n          columnNumber: 12\n        }\n      });\n    }\n    /**\n     *\n     * @method renderImage\n     * @summary If a `props.src` is provided call `renderImg` else call `renderResponsiveImage`\n     * @return {Element} - `picture` or `img`\n     */\n\n  }, {\n    key: \"renderImage\",\n    value: function renderImage() {\n      var src = this.props.src;\n      return src ? this.renderImg() : this.renderResponsiveImage();\n    }\n    /**\n     *\n     * @method renderLoadingImage\n     * @summary Renders a `img` element with the provided `props.presrc`\n     * once the full res image has loaded this `img` will fade out\n     * @return {Element} - `img`\n     */\n\n  }, {\n    key: \"renderLoadingImage\",\n    value: function renderLoadingImage() {\n      var _this$props6 = this.props,\n          fit = _this$props6.fit,\n          presrc = _this$props6.presrc;\n      var _this$props7 = this.props,\n          imgW = _this$props7.imgW,\n          imgH = _this$props7.imgH;\n      var ready = this.state.ready;\n      return /*#__PURE__*/React.createElement(Img, {\n        src: presrc,\n        isLoading: true,\n        isHidden: ready,\n        alt: \"\",\n        fit: fit,\n        width: imgW,\n        height: imgH,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 264,\n          columnNumber: 7\n        }\n      });\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this5 = this;\n\n      var _this$props8 = this.props,\n          className = _this$props8.className,\n          presrc = _this$props8.presrc,\n          imgW = _this$props8.imgW,\n          imgH = _this$props8.imgH;\n      var ready = this.state.ready; //--console.log(imgH, imgW, \"Pulkitiifasd,,,\")\n\n      return /*#__PURE__*/React.createElement(ImageWrapper, {\n        imgH: imgH,\n        imgW: imgW,\n        className: className,\n        ref: function ref(wrapper) {\n          _this5._wrapper = wrapper;\n        },\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 281,\n          columnNumber: 7\n        }\n      }, ready ? this.renderImage() : null, presrc && this.renderLoadingImage());\n    }\n  }, {\n    key: \"supportIntersectionObserver\",\n\n    /**\n     *\n     * @method supportIntersectionObserver\n     * @summary `IntersectionObserver` feature detection\n     * @return {Boolean} - `true` if `IntersectionObserver` is supported by browser\n     */\n    get: function get() {\n      if (false) {\n        return false;\n      }\n\n      return \"IntersectionObserver\" in window;\n    }\n  }]);\n\n  return ProgressiveImage;\n}(Component);\n\n_defineProperty(ProgressiveImage, \"propTypes\", {\n  /**\n   * Image text alternative - https://www.w3.org/TR/WCAG20-TECHS/H37.html\n   */\n  altText: PropTypes.string,\n\n  /**\n   * You can provide a `className` prop that will be applied to the outermost DOM element\n   * rendered by this component. We do not recommend using this for styling purposes, but\n   * it can be useful as a selector in some situations.\n   */\n  className: PropTypes.string,\n\n  /**\n   * How the image should fit its container. \"contain\" (100% width, auto-scaled height, no clipping),\n   * or \"cover\" (100% height, auto-scaled width centered horizontally, with clipping). Both options maintain the image's original aspect ratio.\n   */\n  imgH: PropTypes.string,\n  imgW: PropTypes.string,\n  fit: PropTypes.string,\n\n  /**\n   * Pre load image source: Provide a tiny version of the image to create a medium like progressive loading effect\n   */\n  presrc: PropTypes.string,\n\n  /**\n   * Image source\n   */\n  src: PropTypes.string,\n\n  /**\n   * Image sources - used to create a responsive image via the picture tag\n   */\n  srcs: PropTypes.shape({\n    large: PropTypes.string,\n    medium: PropTypes.string,\n    small: PropTypes.string\n  })\n});\n\n_defineProperty(ProgressiveImage, \"defaultProps\", {\n  altText: \"\",\n  fit: \"contain\"\n});\n\nexport default ProgressiveImage;\n\nvar _c, _c2;\n\n$RefreshReg$(_c, \"ImageWrapper\");\n$RefreshReg$(_c2, \"Img\");","map":{"version":3,"sources":["/usr/local/src/app/packages/craflo-frontend/src/reaction/components/ProgressiveImage/ProgressiveImage.tsx"],"names":["React","Component","PropTypes","ContainerQuery","styled","applyTheme","NextImage","imageContainerQueries","isLargeWidth","minWidth","ImageWrapper","div","props","imgH","Img","fit","fixWidth","isLoading","isLoaded","isHidden","styles","ProgressiveImage","ready","_mounted","lazyLoad","supportIntersectionObserver","viewportIntersection","IntersectionObserver","entries","forEach","entry","intersectionRatio","state","loadImage","root","rootMargin","threshold","observe","_wrapper","src","srcs","buffer","Image","onload","setState","medium","altText","large","imgW","params","renderImg","renderResponsiveImage","presrc","className","wrapper","renderImage","renderLoadingImage","window","string","shape","small"],"mappings":"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","sourcesContent":["import React, { Component } from \"react\";\nimport PropTypes from \"prop-types\";\nimport { ContainerQuery } from \"react-container-query\";\nimport styled from \"styled-components\";\nimport { applyTheme } from \"@reactioncommerce/components/utils\";\nimport NextImage from 'next/image'\n\nconst imageContainerQueries = {\n  isLargeWidth: {\n    minWidth: 301 // Use medium image (600px) until container width is greater than image width / 2 (up to 2x scaling)\n  }\n};\n\n/**\n * @file Image component does a \"Medium/Instagram\" like progressive loading effect for images.\n * To achieve this the component first renders an img element with a tiny version of the full resolution image.\n * This low res image should download quickly and will be blurred by the CSS removing the pixelation.\n * The component then creates an Image buffer with a src of the full resolution image.\n * Once the buffer loads the full resolution image the blurred low res img will fade out revealing the full res image.\n *\n */\n\nconst ImageWrapper = styled.div`\n  background-color: ${applyTheme(\"ProgressiveImage.backgroundColor\")};\n  display: block;\n  height: ${props => props.imgH}px;\n  overflow: hidden;\n  padding-top: 100%;\n  position: relative;\n  border-radius: 0.75rem 0.75rem  0.75rem 0.75rem;\n  width: 100%;\n  padding: 0px;\n  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);\n  transition-delay: 0.05s;\n  &:hover {\n    transform: scale(1.05);\n  }\n`;\n\nconst Img = styled(NextImage)`\n  width: ${({ fit }) => (fit === \"contain\" && \"100%\") || \"auto\"};\n  height: ${({ fit, fixWidth }) => (fit === \"cover\" && \"100%\") || \"auto\"};\n  left: 50% !important;\n  opacity: 1;\n  position: absolute;\n  transition: opacity 300ms cubic-bezier(0.4, 0, 0.2, 1);\n  top: 50% !important;\n  transform: translate(-50%, -50%);\n\n  ${({ isLoading, isLoaded, isHidden }) => {\n  let styles = \"\";\n\n  if (isLoading) {\n    styles += `\n        filter: blur(8px);\n        z-index: 9;`;\n  }\n  if (isLoaded) {\n    styles += \"z-index: 0;\";\n  }\n  if (isHidden) {\n    styles += \"opacity: 0;\";\n  }\n\n  return styles;\n}}\n`;\n\nclass ProgressiveImage extends Component {\n  static propTypes = {\n    /**\n     * Image text alternative - https://www.w3.org/TR/WCAG20-TECHS/H37.html\n     */\n    altText: PropTypes.string,\n    /**\n     * You can provide a `className` prop that will be applied to the outermost DOM element\n     * rendered by this component. We do not recommend using this for styling purposes, but\n     * it can be useful as a selector in some situations.\n     */\n    className: PropTypes.string,\n    /**\n     * How the image should fit its container. \"contain\" (100% width, auto-scaled height, no clipping),\n     * or \"cover\" (100% height, auto-scaled width centered horizontally, with clipping). Both options maintain the image's original aspect ratio.\n     */\n    imgH: PropTypes.string,\n    imgW: PropTypes.string,\n\n    fit: PropTypes.string,\n    /**\n     * Pre load image source: Provide a tiny version of the image to create a medium like progressive loading effect\n     */\n    presrc: PropTypes.string,\n    /**\n     * Image source\n     */\n    src: PropTypes.string,\n    /**\n     * Image sources - used to create a responsive image via the picture tag\n     */\n    srcs: PropTypes.shape({\n      large: PropTypes.string,\n      medium: PropTypes.string,\n      small: PropTypes.string\n    })\n  };\n\n  static defaultProps = {\n    altText: \"\",\n    fit: \"contain\"\n  };\n\n  state = { ready: false };\n\n  componentDidMount() {\n    this._mounted = true;\n    if (typeof window !== \"undefined\") {\n      this.lazyLoad();\n    }\n  }\n\n  componentWillUnmount() {\n    this._mounted = false;\n  }\n\n  /**\n   * Private check for component mount, used in image buffer\n   */\n  _mounted = false;\n\n  /**\n   * Private prop for the img wrapper div, used in intersection observer\n   */\n  _wrapper = null;\n\n  /**\n   *\n   * @method supportIntersectionObserver\n   * @summary `IntersectionObserver` feature detection\n   * @return {Boolean} - `true` if `IntersectionObserver` is supported by browser\n   */\n  get supportIntersectionObserver() {\n    if (typeof window === \"undefined\") {\n      return false;\n    }\n    return \"IntersectionObserver\" in window;\n  }\n\n  /**\n   *\n   * @method lazyLoad\n   * @summary If `IntersectionObserver` is supported create a new one and watch for the `_wrapper` element\n   * to scroll within the viewport, once it's with 50px of the viewport start loading the full res image.\n   * If the `IntersectionObserver` isn't supported just load the image normally.\n   * https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API\n   * @return {Undefined} Nothing\n   */\n  lazyLoad() {\n    if (this.supportIntersectionObserver) {\n      const viewportIntersection = new IntersectionObserver(\n        (entries) => {\n          entries.forEach((entry) => {\n            if (entry.intersectionRatio > 0 && !this.state.ready) {\n              this.loadImage();\n            }\n          });\n        },\n        { root: null, rootMargin: \"50px 0px\", threshold: 0.01 }\n      );\n\n      viewportIntersection.observe(this._wrapper);\n    } else {\n      this.loadImage();\n    }\n  }\n\n  /**\n   *\n   * @method loadImage\n   * @summary Create a new `Image` buffer and set the `src` to be\n   * ether the `props.src` or `props.srcs.medium` if a responsive picture.\n   * Once the buffer loads set the `ready` state to `true`\n   * @return {Undefined} Nothing\n   */\n  loadImage() {\n    const { src, srcs } = this.props;\n    const buffer = new Image();\n    buffer.onload = () => {\n      this._mounted && this.setState({ ready: true });\n    };\n    buffer.src = src || (srcs && srcs.medium);\n  }\n\n  /**\n   *\n   * @method renderResponsiveImage\n   * @summary Renders an image that uses medium by default, and large when appropriate container width\n   *  (see imageContainerQueries definition)\n   * @return {Element} - `picture`\n   */\n  renderResponsiveImage() {\n    const { altText, fit, srcs } = this.props;\n    const { medium, large } = srcs;\n    const {imgW, imgH } = this.props;\n\n    return (\n      <ContainerQuery query={imageContainerQueries}>\n        {(params) => {\n          let src = medium;\n          const { isLargeWidth } = params;\n          if (isLargeWidth) {\n            src = large;\n          }\n\n          return (\n            <Img\n              src={src}\n              isLoaded={true}\n              alt={altText}\n              fit={fit}\n              width={imgW}\n              height={imgH}\n            />\n          );\n        }}\n      </ContainerQuery>\n    );\n  }\n\n  /**\n   *\n   * @method renderImg\n   * @summary Renders a `img` element with the provided `props.src`\n   * @return {Element} - `img`\n   */\n  renderImg() {\n    const { altText, fit, src } = this.props;\n    const {imgW, imgH } = this.props;\n    return <Img src={src} isLoaded={true} alt={altText} fit={fit} width={imgW} height={imgH}/>;\n  }\n\n  /**\n   *\n   * @method renderImage\n   * @summary If a `props.src` is provided call `renderImg` else call `renderResponsiveImage`\n   * @return {Element} - `picture` or `img`\n   */\n  renderImage() {\n    const { src } = this.props;\n    return src ? this.renderImg() : this.renderResponsiveImage();\n  }\n\n  /**\n   *\n   * @method renderLoadingImage\n   * @summary Renders a `img` element with the provided `props.presrc`\n   * once the full res image has loaded this `img` will fade out\n   * @return {Element} - `img`\n   */\n  renderLoadingImage() {\n    const { fit, presrc } = this.props;\n    const {imgW, imgH } = this.props;\n    const { ready } = this.state;\n    return (\n      <Img\n        src={presrc}\n        isLoading={true}\n        isHidden={ready}\n        alt=\"\"\n        fit={fit}\n        width={imgW}\n        height={imgH}\n      />\n    );\n  }\n\n  render() {\n    const { className, presrc, imgW, imgH } = this.props;\n    const { ready } = this.state;\n    //--console.log(imgH, imgW, \"Pulkitiifasd,,,\")\n    return (\n      <ImageWrapper imgH={imgH} imgW={imgW} className={className} ref={(wrapper) => { this._wrapper = wrapper; }}>\n        {ready ? this.renderImage() : null}\n        {presrc && this.renderLoadingImage()}\n      </ImageWrapper>\n    )\n  }\n}\n\nexport default ProgressiveImage;\n"]},"metadata":{},"sourceType":"module"}