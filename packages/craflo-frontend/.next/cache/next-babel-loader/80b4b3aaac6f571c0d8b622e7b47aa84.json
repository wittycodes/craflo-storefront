{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { ApolloClient, ApolloLink, HttpLink, InMemoryCache, fromPromise } from \"@apollo/client\";\nimport { setContext } from \"@apollo/link-context\";\nimport { onError } from \"@apollo/link-error\";\nimport fetch from \"isomorphic-unfetch\";\nimport { omitTypenameLink } from \"./omitVariableTypenameLink\";\nconst REFRESH_PATH = \"/refresh\";\nconst STATUS_BAD_REQUEST = 400;\nconst STATUS_UNAUTHORIZED = 401;\nlet token;\n/**\n * @summary Set the access token that GraphQL requests will use in the Authorization header\n * @param {String} value New token value\n * @return {undefined}\n */\n\nexport function setAccessToken(value) {\n  token = value;\n}\n\nconst getNewToken = async () => {\n  const result = await fetch(REFRESH_PATH, {\n    method: \"GET\",\n    credentials: \"include\"\n  });\n  const data = await result.json();\n  return data;\n};\n\nlet isRefreshing = false;\nlet pendingRequests = [];\n\nconst resolvePendingRequests = () => {\n  pendingRequests.map(callback => callback());\n  pendingRequests = [];\n};\n/**\n* Instantiate the Apollo client\n * @returns {Object} a new Apollo Client instance\n */\n\n\nexport default function createApolloClient() {\n  // Config\n  let graphqlUrl;\n  /* eslint-disable prefer-destructuring */\n\n  if (false) {\n    graphqlUrl = process.env.EXTERNAL_GRAPHQL_URL;\n  } else {\n    graphqlUrl = process.env.INTERNAL_GRAPHQL_URL;\n  }\n\n  const httpLink = new HttpLink({\n    uri: graphqlUrl,\n    credentials: \"same-origin\",\n    fetch\n  }); // error handling for Apollo Link\n\n  const errorLink = onError(apolloError => {\n    const {\n      graphQLErrors,\n      networkError,\n      operation,\n      forward\n    } = apolloError;\n\n    if (graphQLErrors) {\n      graphQLErrors.forEach(({\n        message,\n        locations,\n        path\n      }) => {\n        // eslint-disable-next-line no-console\n        console.error(`[GraphQL error]: ${message}`, {\n          locations,\n          operationName: operation && operation.operationName,\n          path\n        });\n      });\n    }\n\n    if (networkError) {\n      const errorCode = networkError.response && networkError.response.status;\n\n      if (errorCode === STATUS_UNAUTHORIZED) {\n        // If a 401 Unauthorized error occurred, silently refresh the token from /refresh.\n        // This will re-authenticate the user without showing a login page and a new token is issued.\n        let pendingRequestsQueue;\n\n        if (!isRefreshing) {\n          isRefreshing = true;\n          pendingRequestsQueue = fromPromise(getNewToken() // eslint-disable-next-line promise/always-return\n          .then(({\n            accessToken\n          }) => {\n            setAccessToken(accessToken);\n            resolvePendingRequests();\n          }).catch(error => {\n            pendingRequests = [];\n            setAccessToken(); // eslint-disable-next-line no-console\n\n            console.error(error);\n          }).finally(() => {\n            isRefreshing = false;\n          }));\n        } else {\n          // We already have a pending refresh, therefore add the request to the queue\n          // The request will be resolved after the token refresh finished and all previous requests resolved.\n          pendingRequestsQueue = fromPromise(new Promise(resolve => {\n            pendingRequests.push(() => resolve());\n          }));\n        }\n\n        return pendingRequestsQueue.flatMap(() => forward(operation));\n      }\n\n      if (errorCode !== STATUS_BAD_REQUEST) {\n        // eslint-disable-next-line no-console\n        console.error(`Unable to access the GraphQL API. Is it running and accessible at ${graphqlUrl} from the Storefront UI server?`);\n      }\n    } // Default\n\n\n    return null;\n  }); // Set auth context\n  // https://github.com/apollographql/apollo-link/tree/master/packages/apollo-link-context\n\n  const authLink = setContext((_, {\n    headers\n  }) => ({\n    headers: _objectSpread(_objectSpread({}, headers), token ? {\n      Authorization: token\n    } : {})\n  })); // Check out https://github.com/zeit/next.js/pull/4611 if you want to use the AWSAppSyncClient\n\n  return new ApolloClient({\n    ssrMode: false,\n    link: ApolloLink.from([omitTypenameLink, errorLink, authLink, httpLink]),\n    cache: new InMemoryCache({\n      typePolicies: {}\n    })\n  });\n}","map":{"version":3,"sources":["/usr/local/src/app/packages/craflo-frontend/src/reaction/lib/apollo/apolloClient.tsx"],"names":["ApolloClient","ApolloLink","HttpLink","InMemoryCache","fromPromise","setContext","onError","fetch","omitTypenameLink","REFRESH_PATH","STATUS_BAD_REQUEST","STATUS_UNAUTHORIZED","token","setAccessToken","value","getNewToken","result","method","credentials","data","json","isRefreshing","pendingRequests","resolvePendingRequests","map","callback","createApolloClient","graphqlUrl","process","env","EXTERNAL_GRAPHQL_URL","INTERNAL_GRAPHQL_URL","httpLink","uri","errorLink","apolloError","graphQLErrors","networkError","operation","forward","forEach","message","locations","path","console","error","operationName","errorCode","response","status","pendingRequestsQueue","then","accessToken","catch","finally","Promise","resolve","push","flatMap","authLink","_","headers","Authorization","ssrMode","link","from","cache","typePolicies"],"mappings":"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","sourcesContent":["import { ApolloClient, ApolloLink, HttpLink, InMemoryCache, fromPromise } from \"@apollo/client\";\nimport { setContext } from \"@apollo/link-context\";\nimport { onError } from \"@apollo/link-error\";\nimport fetch from \"isomorphic-unfetch\";\nimport { omitTypenameLink } from \"./omitVariableTypenameLink\";\n\nconst REFRESH_PATH = \"/refresh\";\nconst STATUS_BAD_REQUEST = 400;\nconst STATUS_UNAUTHORIZED = 401;\n\nlet token;\n\n/**\n * @summary Set the access token that GraphQL requests will use in the Authorization header\n * @param {String} value New token value\n * @return {undefined}\n */\nexport function setAccessToken(value) {\n  token = value;\n}\n\nconst getNewToken = async () => {\n  const result = await fetch(REFRESH_PATH, {\n    method: \"GET\",\n    credentials: \"include\"\n  });\n  const data = await result.json();\n\n  return data;\n};\n\nlet isRefreshing = false;\nlet pendingRequests = [];\n\nconst resolvePendingRequests = () => {\n  pendingRequests.map((callback) => callback());\n  pendingRequests = [];\n};\n\n/**\n* Instantiate the Apollo client\n * @returns {Object} a new Apollo Client instance\n */\nexport default function createApolloClient() {\n  // Config\n  let graphqlUrl;\n\n  /* eslint-disable prefer-destructuring */\n  if (process.browser) {\n    graphqlUrl = process.env.EXTERNAL_GRAPHQL_URL;\n  } else {\n    graphqlUrl = process.env.INTERNAL_GRAPHQL_URL;\n  }\n\n  const httpLink = new HttpLink({ uri: graphqlUrl, credentials: \"same-origin\", fetch });\n\n  // error handling for Apollo Link\n  const errorLink = onError((apolloError) => {\n    const { graphQLErrors, networkError, operation, forward } = apolloError;\n\n    if (graphQLErrors) {\n      graphQLErrors.forEach(({ message, locations, path }) => {\n        // eslint-disable-next-line no-console\n        console.error(`[GraphQL error]: ${message}`, {\n          locations,\n          operationName: operation && operation.operationName,\n          path\n        });\n      });\n    }\n\n    if (networkError) {\n      const errorCode = networkError.response && networkError.response.status;\n      if (errorCode === STATUS_UNAUTHORIZED) {\n        // If a 401 Unauthorized error occurred, silently refresh the token from /refresh.\n        // This will re-authenticate the user without showing a login page and a new token is issued.\n\n        let pendingRequestsQueue;\n        if (!isRefreshing) {\n          isRefreshing = true;\n          pendingRequestsQueue = fromPromise(getNewToken()\n          // eslint-disable-next-line promise/always-return\n            .then(({ accessToken }) => {\n              setAccessToken(accessToken);\n              resolvePendingRequests();\n            })\n            .catch((error) => {\n              pendingRequests = [];\n              setAccessToken();\n              // eslint-disable-next-line no-console\n              console.error(error);\n            })\n            .finally(() => {\n              isRefreshing = false;\n            }));\n        } else {\n          // We already have a pending refresh, therefore add the request to the queue\n          // The request will be resolved after the token refresh finished and all previous requests resolved.\n          pendingRequestsQueue = fromPromise(new Promise((resolve) => {\n            pendingRequests.push(() => resolve());\n          }));\n        }\n\n        return pendingRequestsQueue.flatMap(() => forward(operation));\n      }\n      if (errorCode !== STATUS_BAD_REQUEST) {\n        // eslint-disable-next-line no-console\n        console.error(`Unable to access the GraphQL API. Is it running and accessible at ${graphqlUrl} from the Storefront UI server?`);\n      }\n    }\n\n    // Default\n    return null;\n  });\n\n  // Set auth context\n  // https://github.com/apollographql/apollo-link/tree/master/packages/apollo-link-context\n  const authLink = setContext((_, { headers }) => ({\n    headers: {\n      ...headers,\n      ...(token ? { Authorization: token } : {})\n    }\n  }));\n\n  // Check out https://github.com/zeit/next.js/pull/4611 if you want to use the AWSAppSyncClient\n  return new ApolloClient({\n    ssrMode: false,\n    link: ApolloLink.from([omitTypenameLink, errorLink, authLink, httpLink]),\n    cache: new InMemoryCache({\n      typePolicies: {\n      }\n    })\n  });\n}\n"]},"metadata":{},"sourceType":"module"}