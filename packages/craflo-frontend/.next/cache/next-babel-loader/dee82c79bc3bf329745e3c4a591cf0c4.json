{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * Load next page of content for a Apollo GraphQL query\n * @name loadNextPage\n * @param {Object} args Args for pagination\n * @param {String} args.queryName Name of the GraphQL whose result will be used to paginate\n * @param {Object} args.data Full result from GraphQl\n * @param {Object} args.limit Limit\n * @param {Object} args.fetchMore fetchMore function\n * @returns {Function} load next page function\n */\nexport const loadNextPage = ({\n  queryName,\n  data,\n  limit,\n  fetchMore,\n  routingStore\n}) => () => {\n  if (!queryName) throw new Error(\"queryName is required\");\n  const cursor = data[queryName].pageInfo.endCursor; // Set URL search params to allow for link sharing\n\n  if (routingStore) {\n    routingStore.setSearch({\n      limit,\n      after: cursor\n    });\n  }\n\n  fetchMore({\n    variables: {\n      first: limit,\n      after: cursor,\n      last: null,\n      before: null\n    },\n    updateQuery: (previousResult, {\n      fetchMoreResult\n    }) => {\n      const {\n        [queryName]: items\n      } = fetchMoreResult; // Return with additional results\n\n      if (items.edges.length) {\n        return fetchMoreResult;\n      } // Send the previous result if the new result contains no additional data\n\n\n      return previousResult;\n    }\n  });\n};\n/**\n * Load previous page of content for a Apollo GraphQL query\n * @name loadPreviousPage\n * @param {Object} args Args for pagination\n * @param {String} args.queryName Name of the GraphQL whose result will be used to paginate\n * @param {Object} args.data Full result from GraphQl\n * @param {Object} args.limit Limit\n * @param {Object} args.fetchMore fetchMore function\n * @returns {Function} load next page function\n */\n\nexport const loadPreviousPage = ({\n  queryName,\n  data,\n  limit,\n  fetchMore,\n  routingStore\n}) => () => {\n  if (!queryName) throw new Error(\"queryName is required\");\n  const cursor = data[queryName].pageInfo.startCursor; // Set URL search params to allow for link sharing\n\n  if (routingStore) {\n    routingStore.setSearch({\n      limit,\n      before: cursor\n    });\n  }\n\n  fetchMore({\n    variables: {\n      first: null,\n      after: null,\n      last: limit,\n      before: cursor\n    },\n    updateQuery: (previousResult, {\n      fetchMoreResult\n    }) => {\n      const {\n        [queryName]: items\n      } = fetchMoreResult; // Return with additional results\n\n      if (items.edges.length) {\n        return fetchMoreResult;\n      } // Send the previous result if the new result contains no additional data\n\n\n      return previousResult;\n    }\n  });\n};\n/**\n * Create pagination functions for next and previous and page info data\n * @name pagination\n * @param {Object} args Args for pagination\n * @param {String} args.queryName Name of the GraphQL whose result will be used to paginate\n * @param {Object} args.data Full result from GraphQl\n * @param {Object} args.limit Limit\n * @param {Object} args.fetchMore fetchMore function\n * @returns {Function} load next page function\n */\n\nexport const pagination = args => {\n  const {\n    queryName,\n    data\n  } = args;\n  if (!queryName) throw new Error(\"queryName is required\");\n  const pageInfo = data && data[queryName] && data[queryName].pageInfo || {};\n  return _objectSpread(_objectSpread({}, pageInfo), {}, {\n    loadNextPage: loadNextPage(args),\n    loadPreviousPage: loadPreviousPage(args)\n  });\n};\n/**\n * Create an object of variables for pagination a GraphQL query.\n * @name paginationVariablesFromUrlParams\n * @param {Object} params Object of params to create query variables from\n * @param {Number|String} params.limit Maximum number of items to get\n * @param {String} params.before Before Cursor\n * @param {String} params.after After cursor\n * @param {Options} options Additional options\n * @param {Number} options.defaultLimit After cursor\n * @returns {Object} Object of variables for GraphQL query\n */\n\nexport const paginationVariablesFromUrlParams = (params, options) => {\n  const {\n    limit,\n    before,\n    after\n  } = params || {};\n  const {\n    defaultPageLimit\n  } = options || {};\n  const variables = {};\n\n  if (limit && after) {\n    variables.first = parseInt(limit, 10);\n  } else if (limit && before) {\n    variables.last = parseInt(limit, 10);\n  } else if (limit) {\n    variables.first = parseInt(limit, 10);\n  } else if (defaultPageLimit) {\n    variables.first = defaultPageLimit;\n  }\n\n  if (after) {\n    variables.after = after;\n  } else if (before) {\n    variables.before = before;\n  }\n\n  return variables;\n};","map":{"version":3,"sources":["/usr/local/src/app/packages/craflo-frontend/src/reaction/lib/utils/pagination.tsx"],"names":["loadNextPage","queryName","data","limit","fetchMore","routingStore","Error","cursor","pageInfo","endCursor","setSearch","after","variables","first","last","before","updateQuery","previousResult","fetchMoreResult","items","edges","length","loadPreviousPage","startCursor","pagination","args","paginationVariablesFromUrlParams","params","options","defaultPageLimit","parseInt"],"mappings":"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","sourcesContent":["/**\n * Load next page of content for a Apollo GraphQL query\n * @name loadNextPage\n * @param {Object} args Args for pagination\n * @param {String} args.queryName Name of the GraphQL whose result will be used to paginate\n * @param {Object} args.data Full result from GraphQl\n * @param {Object} args.limit Limit\n * @param {Object} args.fetchMore fetchMore function\n * @returns {Function} load next page function\n */\nexport const loadNextPage = ({ queryName, data, limit, fetchMore, routingStore }) => () => {\n  if (!queryName) throw new Error(\"queryName is required\");\n\n  const cursor = data[queryName].pageInfo.endCursor;\n\n  // Set URL search params to allow for link sharing\n  if (routingStore) {\n    routingStore.setSearch({ limit, after: cursor });\n  }\n\n  fetchMore({\n    variables: {\n      first: limit,\n      after: cursor,\n      last: null,\n      before: null\n    },\n    updateQuery: (previousResult, { fetchMoreResult }) => {\n      const { [queryName]: items } = fetchMoreResult;\n\n      // Return with additional results\n      if (items.edges.length) {\n        return fetchMoreResult;\n      }\n\n      // Send the previous result if the new result contains no additional data\n      return previousResult;\n    }\n  });\n};\n\n/**\n * Load previous page of content for a Apollo GraphQL query\n * @name loadPreviousPage\n * @param {Object} args Args for pagination\n * @param {String} args.queryName Name of the GraphQL whose result will be used to paginate\n * @param {Object} args.data Full result from GraphQl\n * @param {Object} args.limit Limit\n * @param {Object} args.fetchMore fetchMore function\n * @returns {Function} load next page function\n */\nexport const loadPreviousPage = ({ queryName, data, limit, fetchMore, routingStore }) => () => {\n  if (!queryName) throw new Error(\"queryName is required\");\n\n  const cursor = data[queryName].pageInfo.startCursor;\n\n  // Set URL search params to allow for link sharing\n  if (routingStore) {\n    routingStore.setSearch({ limit, before: cursor });\n  }\n\n  fetchMore({\n    variables: {\n      first: null,\n      after: null,\n      last: limit,\n      before: cursor\n    },\n    updateQuery: (previousResult, { fetchMoreResult }) => {\n      const { [queryName]: items } = fetchMoreResult;\n\n      // Return with additional results\n      if (items.edges.length) {\n        return fetchMoreResult;\n      }\n\n      // Send the previous result if the new result contains no additional data\n      return previousResult;\n    }\n  });\n};\n\n/**\n * Create pagination functions for next and previous and page info data\n * @name pagination\n * @param {Object} args Args for pagination\n * @param {String} args.queryName Name of the GraphQL whose result will be used to paginate\n * @param {Object} args.data Full result from GraphQl\n * @param {Object} args.limit Limit\n * @param {Object} args.fetchMore fetchMore function\n * @returns {Function} load next page function\n */\nexport const pagination = (args) => {\n  const { queryName, data } = args;\n\n  if (!queryName) throw new Error(\"queryName is required\");\n\n  const pageInfo = (data && data[queryName] && data[queryName].pageInfo) || {};\n\n  return {\n    ...pageInfo,\n    loadNextPage: loadNextPage(args),\n    loadPreviousPage: loadPreviousPage(args)\n  };\n};\n\n/**\n * Create an object of variables for pagination a GraphQL query.\n * @name paginationVariablesFromUrlParams\n * @param {Object} params Object of params to create query variables from\n * @param {Number|String} params.limit Maximum number of items to get\n * @param {String} params.before Before Cursor\n * @param {String} params.after After cursor\n * @param {Options} options Additional options\n * @param {Number} options.defaultLimit After cursor\n * @returns {Object} Object of variables for GraphQL query\n */\nexport const paginationVariablesFromUrlParams = (params, options) => {\n  const { limit, before, after } = params || {};\n  const { defaultPageLimit } = options || {};\n  const variables = {};\n\n  if (limit && after) {\n    variables.first = parseInt(limit, 10);\n  } else if (limit && before) {\n    variables.last = parseInt(limit, 10);\n  } else if (limit) {\n    variables.first = parseInt(limit, 10);\n  } else if (defaultPageLimit) {\n    variables.first = defaultPageLimit;\n  }\n\n  if (after) {\n    variables.after = after;\n  } else if (before) {\n    variables.before = before;\n  }\n\n  return variables;\n};\n"]},"metadata":{},"sourceType":"module"}